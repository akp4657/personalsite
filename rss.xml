<?xml version="1.0" encoding="UTF-8"?><rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>Anthony Pichardo</title><description>No description</description><link>https://akp4657.github.io/portfolio/</link><language>en</language><item><title>Redis Caching for Faster Queries</title><link>https://akp4657.github.io/posts/redisblogpost/redisblogpost/</link><guid isPermaLink="true">https://akp4657.github.io/posts/redisblogpost/redisblogpost/</guid><description>Blog post from SandBox Union about Redis Caching</description><pubDate>Thu, 19 Sep 2024 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;This post was originally posted on &lt;a href=&quot;https://sandboxunion.com/redis-caching-for-faster-queries/&quot;&gt;SandBox Union&apos;s blog&lt;/a&gt;, written by me on September 29, 2022.&lt;/p&gt;
&lt;p&gt;So, sometimes we have development problems—we run into what is a significant hurdle for any database: As the amount of data grows, how can we ensure that our queries are executing as fast as possible? This problem gets exacerbated as we begin to use relational data and try to return said relations. Eventually, one may run into a scenario where they are not only querying thousands of rows from one table, but then thousands of rows from a related table, and then another thousand rows from another corresponding table, and so on.&lt;/p&gt;
&lt;h2&gt;Why do queries slow down when there’s a lot of data? Shouldn’t this be easy for the DB?&lt;/h2&gt;
&lt;p&gt;It is easy for the DB to fetch the data. The problem is when we use our ORM (Object–Relational Mapping tool) of choice, in this case, Sequelize, then things slow down considerably when we have to-Many (:M) relationships relating to each other. Having :M relations in the :M includes our query results in duplicate rows in our returned data. A way to think about it is this:&lt;/p&gt;
&lt;p&gt;Say we have a bunch of students in a database, and we want to get a list of the students’ names, classes, and projects. Students can be in multiple classes, and there can be numerous projects in each class. So, it’s perfectly valid to list a student’s name three times for each student: Student A, Student A in Class A, and Student A in Class A, who is assigned Project A. However, this is redundant. We only need to return the student once; the rest of their data can be below them. This elimination of redundancy is normally what Sequelize would do for us.&lt;/p&gt;
&lt;p&gt;So, Sequelize spends a lot of time deduplicating and putting the data in our desired format. Very nice of Sequelize to do, but it slows down tremendously when it has to sift through thousands of rows and deduplicate thousands of times. This issue was happening to us in a few of our calls. It was severe enough to cause a GET query to take, on average, a little over 30 seconds to complete. Many of the attempted solutions fell short, as the fundamental problem was the deduplication from the :M relationships. It was getting to the point where we were about to re-write our frontend and backend—until we tried Redis caching.&lt;/p&gt;
&lt;h2&gt;What is Redis Caching?&lt;/h2&gt;
&lt;p&gt;Before we get into Redis caching, what is Redis? Redis is, by their official definition, “The open source, in-memory data store used by millions of developers as a database, cache, streaming engine, and message broker.” Essentially, Redis is another DB focused on and known for its fast performance. However, what’s important to us and this problem is its caching capability. Redis provides a speedy solution to access large datasets by caching the results of a large query into the Redis DB. Redis removes the deduplication issue entirely, as we now get the results from the Redis instance instead of our primary SQL DB on each call.&lt;/p&gt;
&lt;h2&gt;How to Implement Redis?&lt;/h2&gt;
&lt;p&gt;Redis caching is surprisingly simple to implement, especially starting locally. The documentation is well written, and the process is intuitive in our Node.js environment. After the installation in node and on the machine, the rest is just using redisClient.set() to set your data into the database at a specific key value. We cache on POST, PUT, and DELETE in the background after the data gets sent back to the frontend. On GET calls, we simply need to use the redisClient.get() to get the cached data at the specified key. The result is an extremely fast get query due to no deduplication or formatting required on Sequelizes part.&lt;/p&gt;
&lt;h2&gt;What are the Actual Differences in Speed?&lt;/h2&gt;
&lt;p&gt;Well, as I said before, some of our queries took about 30 seconds or more to complete for the user. Even for our smaller DBs, with fewer than one thousand rows, the calls were taking about 550ms to complete. Half a second seems minuscule, but with a dataset comparatively small, it should be less than 120ms at its worst. So, after implementing Redis caching, the calls went from around 500ms to a consistent 50ms or less—a speed increase of 10x. The most significant change was when we pushed this change into production, where the calls took 30 seconds on average. With our new implementation, it was down to a consistent 220ms! 30000+ms to 220ms for a dataset of thousands of documents with a few :M relations is a massive difference—which everyone has noticed. So, the next time your queries are too slow, and you’re at your wit’s end with whatever ORM, consider looking at Redis caching.&lt;/p&gt;
</content:encoded></item><item><title>WIP - Wrestling Blog</title><link>https://akp4657.github.io/posts/wrestlingblog/</link><guid isPermaLink="true">https://akp4657.github.io/posts/wrestlingblog/</guid><description>Planned project for a wrestling blog using the MEAN stack</description><pubDate>Thu, 19 Sep 2024 00:00:00 GMT</pubDate><content:encoded>&lt;h1&gt;Wrestling Blog&lt;/h1&gt;
&lt;p&gt;Planned solo project&lt;/p&gt;
&lt;p&gt;Tech Stack:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;AngularJS&lt;/li&gt;
&lt;li&gt;NodeJS&lt;/li&gt;
&lt;li&gt;JavaScript&lt;/li&gt;
&lt;li&gt;TypeScript&lt;/li&gt;
&lt;li&gt;MongoDB (House Posts)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;In my spare time, I&apos;m a professional wrestler (yes, really). I train in the evenings during the week and perform on shows throughout Rochester, Buffalo, Syracuse, and even Ontrario on the weekend. There&apos;s
never really a dull moment when it comes to being in this activity. As such, I&apos;ve been meaning to write down my experiences and thoughts as I go on this journey of violent dancing. Initially, I used Medium
to host the blog posts, but I feel I would have more freedom and retention with my intended audience if I build and host the website on my own.&lt;/p&gt;
&lt;p&gt;There are a few ideas I have regarding formats, but I do know the main tech stack I want to use would be a MEAN stack. The project will likely start very soon. In fact, shortly after &lt;em&gt;this&lt;/em&gt; website goes up,
I&apos;ll probably be starting the wrestling blog!&lt;/p&gt;
</content:encoded></item><item><title>StartGG Discord Bot</title><link>https://akp4657.github.io/posts/startggbot/startgg/</link><guid isPermaLink="true">https://akp4657.github.io/posts/startggbot/startgg/</guid><description>Solo project to aid tournament go-ers using StartGG&apos;s GraphQL API</description><pubDate>Wed, 01 May 2024 00:00:00 GMT</pubDate><content:encoded>&lt;h1&gt;StartGG Discord Bot (WIP)&lt;/h1&gt;
&lt;p&gt;Tech Stack:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;StartGG API (GraphQL)&lt;/li&gt;
&lt;li&gt;DiscordJS&lt;/li&gt;
&lt;li&gt;NodeJS&lt;/li&gt;
&lt;li&gt;JavaScript&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;::github{repo=&quot;akp4657/discordbot&quot;}&lt;/p&gt;
&lt;p&gt;My current WIP project. This is a Discord bot built with DiscordJS and StartGG&apos;s GraphQL API. For many tournaments in esports, most organizers choose to use StartGG as it&apos;s easily scalable for large events such as these. However, a main issue users have had with the application is that it is unoptimized for mobile and it doesn&apos;t have a mobile app. As such, during events, it&apos;s difficult for competitors and spectators alike to
view their matches with any sort of consistency on their phone. This Discord bot mitigates this issue by showing relevant data quickly and easily. Currently, I&apos;m the only user for this bot though I do plan to release it to the community later in the year.&lt;/p&gt;
&lt;p&gt;As of writing, the bot has commands to search for tournaments for specific games in your state/region, look up recent match statistics, and display a user&apos;s upcoming matches. I plan on adding a feature to display an entire bracket soon.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;./tournamentbot.PNG&quot; alt=&quot;image info&quot; /&gt;&lt;/p&gt;
</content:encoded></item><item><title>Enchant-Boost</title><link>https://akp4657.github.io/posts/eb/enchant-boost/</link><guid isPermaLink="true">https://akp4657.github.io/posts/eb/enchant-boost/</guid><description>Solo project built in the MERN stack for MAAB</description><pubDate>Thu, 01 Dec 2022 00:00:00 GMT</pubDate><content:encoded>&lt;h1&gt;Video Database for Million Arthur: Arcana Blood&lt;/h1&gt;
&lt;p&gt;&lt;a href=&quot;https://www.enchant-boost.net/&quot;&gt;Enchant-Boost.Net&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Tech Stack:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;MongoDB&lt;/li&gt;
&lt;li&gt;NodeJS&lt;/li&gt;
&lt;li&gt;Express&lt;/li&gt;
&lt;li&gt;ReactJS&lt;/li&gt;
&lt;li&gt;Heroku&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;::github{repo=&quot;akp4657/enchant-boost&quot;}&lt;/p&gt;
&lt;p&gt;Solo project built in the MERN stack very similar to Ignite-Boost. This had a different circumstance compared to &lt;a href=&quot;https://www.ignite-boost.net/&quot;&gt;Ignite-Boost&lt;/a&gt;. &lt;a href=&quot;https://www.enchant-boost.net/&quot;&gt;Enchant-Boost&lt;/a&gt; is for a much smaller game and community: Million Arthur: Arcana Blood. I had a few friends who were community leaders and top players for the game, and had noticed that they kept their video database in an Excel file rather than on a site like &lt;a href=&quot;https://replaytheater.app/&quot;&gt;Replay Theater&lt;/a&gt;. So, I made some adjustments and launched Enchant-Boost for the community that&apos;s still actively used by said community to this day.&lt;/p&gt;
&lt;p&gt;Enchant-Boost has the same stack as Ignite-Boost, but Enchant-Boost&apos;s modifications are specific to Million Arthur as well as having some database optimizations. Much like Ignite-Boost, I&apos;m working on the Angular re-work to better represent my current tech stack.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;./eb.PNG&quot; alt=&quot;image info&quot; /&gt;&lt;/p&gt;
</content:encoded></item><item><title>Ignite-Boost</title><link>https://akp4657.github.io/posts/ib/ignite-boost/</link><guid isPermaLink="true">https://akp4657.github.io/posts/ib/ignite-boost/</guid><description>Solo project built in the MERN stack for DFC</description><pubDate>Sat, 01 May 2021 00:00:00 GMT</pubDate><content:encoded>&lt;h1&gt;Video Database for Dengeki Bunko Fighting Climax Ignition&lt;/h1&gt;
&lt;p&gt;&lt;a href=&quot;https://www.ignite-boost.net/&quot;&gt;Ignite-Boost.Net&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Tech Stack:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;MongoDB&lt;/li&gt;
&lt;li&gt;NodeJS&lt;/li&gt;
&lt;li&gt;Express&lt;/li&gt;
&lt;li&gt;ReactJS&lt;/li&gt;
&lt;li&gt;Heroku&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;::github{repo=&quot;akp4657/ignite-boost&quot;}&lt;/p&gt;
&lt;p&gt;Solo project built in the MERN stack. An issue I discovered while playing and competiting in Dengeki was that there was no centralized place to find videos of matches. Like most activities, watching film is a vital
component to improving. In the fighting game community, there are many dedicated sites to upload and watch film back. A popular one amongst the community is the &lt;a href=&quot;https://replaytheater.app/&quot;&gt;Replay Theater&lt;/a&gt;. However, this
wasn&apos;t around during the rapid growth period of Dengeki&apos;s community. So, during my final year at RIT, I developed and deployed &lt;a href=&quot;https://www.ignite-boost.net/&quot;&gt;Ignite-Boost&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Ignite-Boost was built in the MERN stack along with tools such as Handlebars, Babel, and CI/CD. It&apos;s currently hosted using Heroku with a Production and QA environment. The website receives feedback through my personal Discord server for the site as well as direct communication with community members. As of today, the website hosts over 17,000 entries of videos for Dengeki Bunko Fighting Climax. This is the largest public video database for the game that exists online. As of writing, I&apos;m working on an Angular re-work for both Ignite-Boost and Enchant-Boost in Angular to represent my current stack.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;./ib.PNG&quot; alt=&quot;image info&quot; /&gt;&lt;/p&gt;
</content:encoded></item></channel></rss>